\documentclass[xcolor=pdflatex,dvipsnames,table]{beamer}
\usepackage{epsfig,graphicx}
\usepackage{palatino}
\usepackage{fancybox}
\usepackage{relsize}
\usepackage[procnames]{listings}
\usepackage{hyperref}


% fatter TT font
\renewcommand*\ttdefault{txtt}
% another TT, suggested by Alex
% \usepackage{inconsolata}
% \usepackage[T1]{fontenc} % needed as well?

\usepackage[procnames]{listings}

\input{../shared/chisel.tex}

\hypersetup{
  linkcolor  = black,
%  citecolor  = blue,
  urlcolor   = blue,
  colorlinks = true,
}

\newcommand{\code}[1]{{\texttt{#1}}}

\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}[frame number]

\newcommand{\todo}[1]{{\emph{TODO: #1}}}
\newcommand{\martin}[1]{{\color{blue} Martin: #1}}
\newcommand{\abcdef}[1]{{\color{red} Author2: #1}}

% uncomment following for final submission
%\renewcommand{\todo}[1]{}
%\renewcommand{\martin}[1]{}
%\renewcommand{\author2}[1]{}


\title{Chisel Basic Operations}
\author{Martin Schoeberl}
\date{\today}
\institute{Technical University of Denmark}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[fragile]{Chisel Data Types}
\begin{itemize}
\item Data types for values on wires or state elements
\item Raw collection of bits is type \code{Bits}
\item Simple types to represent integer numbers
\begin{itemize}
\item Unsigned and signed
\item Subtype of \code{Bits}
\end{itemize}
\item Little strange way to specify constants
\item Automatic bit width inference
\item Boolean values are of type \code{Bool}, a single bit value
\end{itemize}
\begin{chisel}
UInt(1)
UInt("habcd")
UInt("b0101")
SInt(-5)
Bool(true)
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Chisel Data Types}
\begin{itemize}
\item Bit width can be explicitly specified
\begin{itemize}
\item \code{SInt} will be sign extended
\item \code{UInt} will be zero extended
\end{itemize}
\end{itemize}
\begin{chisel}
UInt(0, 32)
UInt("habcd", 24)
SInt(-5, 16)
Bool(true)
\end{chisel}
\begin{itemize}
\item \emph{Bundles} for a named collection of values
\item \emph{Vecs} for indexable collection of values
\item Chisel data types are different from Scala builtin types (e.g., Scala's \code{Int})
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Bitwise Logical Operations}
\begin{itemize}
\item Bitwise NOT, AND, OR, and XOR
\item Automatic size extension to larger operand
\end{itemize}
\begin{chisel}
val notVal = ~x
val maskOut = x & UInt("b00001111")
val orVal = x | y
val xorVal = x ^ y
\end{chisel}
\begin{itemize}
\item Bit reduction
\item Results in a \code{Bool}
\end{itemize}
\begin{chisel}
andR(x)
orR(x)
xorR(x)
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Arithmetic Operations}
\begin{itemize}
\item Addition, subtraction, multiplication, division, modulos
\item Automatic size extension to larger operand
\end{itemize}
\begin{chisel}
+, -, *, /, %
\end{chisel}
\begin{itemize}
\item Left and right shifts
\item Left shift extends bit width
\item Right shift reduces bit width
\end{itemize}
\begin{chisel}
<<, >>
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Bitfield Manipulations}
\begin{itemize}
\item Extract a single bit
\end{itemize}
\begin{chisel}
val sign = x(31)
\end{chisel}
\begin{itemize}
\item Extract a sub field from end to start position
\end{itemize}
\begin{chisel}
val lowByte = word(7, 0)
\end{chisel}
\begin{itemize}
\item Concatenate bit fields
\end{itemize}
\begin{chisel}
val word = Cat(highByte, lowByte)
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Comparison}
\begin{itemize}
\item The usual operations
\begin{itemize}
\item Unusual equal and unequal operator symbols
\item To keep the original Sala operators usable
\end{itemize}
\item Operands are \code{UInt} and \code{SInt}
\item Operands can be \code{Bool} for equal and unequal
\item Result is \code{Bool}
\end{itemize}
\begin{chisel}
===, =/=
>, >=, <, <=
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Boolean Logical Operations}
\begin{itemize}
\item Operands and result are \code{Bool}
\item Logical NOT, AND, and OR
\end{itemize}
\begin{chisel}
val notX = !x
val bothTrue = a && b
val orVal = x || y
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Combinational Circuits}
\begin{itemize}
\item Circuit is a graph of nodes
\item A node is a hardware operator with zero or more inputs
\item Textual expression to wire up nodes
\item Named wires with some (unspecified) width
\end{itemize}
\begin{chisel}
(a | b) & ~c
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Combinational Circuits}
\begin{itemize}
\item Simple expressions represent a circuit tree
\item Arbitrary directed acyclic graphs need named subexpressions
\item Using Scala's \code{val} keyword for variables that don't change
\item Referenced multiple times
\end{itemize}
\begin{chisel}
val cond = a & b
val result = (cond & selA) | (!cond & selB)
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Register}
\begin{itemize}
\item State elements
\item Has it's own Chisel type \code{Reg}
\item Positive edge triggered D flip-flop
\item Synchronous reset
\item Clock and reset are \emph{hidden wires}
\end{itemize}
\begin{chisel}
val q = Reg(next = d)
\end{chisel}
\begin{itemize}
\item \code{d} is the input, \code{q} the output
\item Register type is inferred by the input (d) type
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Register}
\begin{itemize}
\item Reset value as \code{init} parameter on definition
\end{itemize}
\begin{chisel}
val initReg = Reg(init = UInt(0, 8))
\end{chisel}
\begin{itemize}
\item With this forward declaration we later assign the next value
\end{itemize}
\begin{chisel}
initReg := initReg + UInt(1)
\end{chisel}
\begin{itemize}
\item A register can also be defined within an expression
\end{itemize}
\begin{chisel}
val risingEdge = d & !Reg(next = d)
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Multiplexer}
\begin{itemize}
\item So common: a component provided by Chisel
\item Could be implemented with conditional updates
\item Automagical type selection on input types
\end{itemize}
\begin{chisel}
val selection = Mux(cond, trueVal, falseVal)
\end{chisel}
\end{frame}

\begin{frame}[fragile]{A Small Circuit}
\begin{itemize}
\item Our Chisel knowledge is complete enough\\ to implement any digital circuit
\item Maybe not in the most elegant way ;-)
\item A counter is a simple basic component
\item The following counts form 0 to 100
\end{itemize}
\begin{chisel}
  val cntReg = Reg(init = UInt(0, 8))

  cntReg := Mux(cntReg === UInt(100),
    UInt(0), cntReg + UInt(1))
\end{chisel}
\end{frame}

\begin{frame}[fragile]{The Complete Counter Module}
\begin{chisel}
class Count extends Module {
  val io = new Bundle {
    val cnt = UInt(OUTPUT, 8)
  }

  val cntReg = Reg(init = UInt(0, 8))

  cntReg := Mux(cntReg === UInt(100),
    UInt(0), cntReg + UInt(1))

  io.cnt := cntReg
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Data Aggregation}
\begin{itemize}
\item A \code{Bundle} groups several named fields
\item Like a C struct or VHDL record
\item \code{Vec} is a vector of elements with the same type
\item Can be arbitrary mixed
\end{itemize}
\begin{chisel}
class AluFields extends Bundle {
  val function = UInt(2)
  val inputA = UInt(8)
  val inputB = UInt(8)
  val result = UInt(8)
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Vectors}
\begin{itemize}
\item Indexable vector of elements
\item Elements can be Chisel basic elements, or bundles
\item Type is specified as second parameter
\end{itemize}
\begin{chisel}
val myVec = Vec(3, SInt(width = 10))
val y = myVec(2)
myVec(0) := SInt(-3)
\end{chisel}
\begin{itemize}
\item A register file as \code{Reg} of a vector
\end{itemize}
\begin{chisel}
val vecReg = Reg(Vec(32, SInt(width = 32)))
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Ports}
\begin{itemize}
\item Ports used to connect modules
\item Ports are bundles with directions
\end{itemize}
\begin{chisel}
class AluIO extends Bundle {
  val function = UInt(INPUT, 2)
  val inputA = UInt(INPUT, 8)
  val inputB = UInt(INPUT, 8)
  val result = UInt(OUTPUT, 8)
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Port Directions}
\begin{itemize}
\item Can be assigned at instantiation
\end{itemize}
\begin{chisel}
class ExecuteIO extends Bundle {
  val dec = new DecodeExecute().asInput
  val mem = new ExecuteMemory().asOutput
}
\end{chisel}
\begin{chisel}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Port Directions}
\begin{itemize}
\item Can be reversed with the \code{flip} operation
\item Convenient to have one bundle definition working as source
and destination used between two modules
\end{itemize}
\begin{chisel}
class Channel extends Bundle {
  val data = UInt(INPUT, 32)
  val ready = Bool(OUTPUT)
  val valid = Bool(INPUT)
}

class ChannelUsage extends Bundle {
  val input = new Channel()
  val output = new Channel().flip()
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Modules}
\begin{itemize}
\item Modules are used to organize the circuit
\item Similar to VHDL components (entity/architecture)
\item A class that inherits from \code{Module}
\item Circuit description in the constructor
\item Interface (port) is a Bundle stored in the field \code{io}
\end{itemize}
\begin{chisel}
class Adder extends Module {
  val io = new Bundle {
    val a = UInt(INPUT, 4)
    val b = UInt(INPUT, 4)
    val result = UInt(OUTPUT, 4)
  }

  val addVal = io.a + io.b
  io.result := addVal
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Module Usage}
\begin{itemize}
\item Create with \code{new} and wrap into a \code{Module()}
\item Interface port via the \code{io} field
\item Note the assignment operator \code{:=} on \code{io} fields
\end{itemize}
\begin{chisel}
val adder = Module(new Adder())
adder.io.a := ina
adder.io.b := inb
val result = adder.io.result
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Conditional Assignments}
\begin{itemize}
\item Conditional update of a value
\item Last assignment counts
\item Is basically a multiplexer
\end{itemize}
\begin{chisel}
val v = UInt(5)
when (condition) {
  v := UInt(0)
}

when (c1) { v := UInt(1) }
when (c2) { v := UInt(2) }
\end{chisel}
\end{frame}

\begin{frame}[fragile]{The Counter With a Conditional Update}
\begin{chisel}
class Count extends Module {
  val io = new Bundle {
    val cnt = UInt(OUTPUT, 8)
  }

  val cntReg = Reg(init = UInt(0, 8))

  cntReg := cntReg + UInt(1)
  when (cntReg === UInt(100)) {
    cntReg := UInt(0)
  }

  io.cnt := cntReg
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Chained Conditionals}
\begin{itemize}
\item Chain of conditionals with \code{.elsewhen}
\item With an optional \emph{else} path with \code{.otherwise}
\item Note that Scala has \code{if/else}
\begin{itemize}
\item Does NOT result in hardware
\item Are used to conditionally \emph{generate} hardware
\item We will look at this later
\end{itemize}
\item Note the ``.'' at the operators
\end{itemize}
\begin{chisel}
when (c1) { v := UInt(1) }
.elsewhen (c2) { v := UInt(2) }
.otherwise { v := UInt(3) }
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Switch Statement}
\begin{itemize}
\item Series of comparisons
\item Chisel allows combinational logic be updated conditionally 
\item Chisel disallows incomplete specified logic (= latches)
\item Chisel will report a runtime error
\end{itemize}
\begin{chisel}
switch(fn) {
  is(UInt(0)) { result := a + b }
  is(UInt(1)) { result := a - b }
  is(UInt(2)) { result := a | b }
  is(UInt(3)) { result := a & b }
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{More Chisel Example Code}
\begin{itemize}
\item The time-predictable processor Patmos
\item An SRAM controller for the DE2-115 board
\item An SSRAM controller
\item An UART
\item A memory arbiter
\item Caches
\item ...
\item \url{https://github.com/t-crest/patmos}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{More Chisel Documentation}
\begin{itemize}
\item Started a textbook on ``Digital Design with Chisel''
\item Considered a work-in-progress (V 0.01 ;-)
\item \url{https://github.com/schoeberl/chisel-book}
\item Feedback is welcome
\item Contains all the slides
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chisel Tutorial from UCB}
\begin{itemize}
\item Collection of small exercises
\item Only in simulation, no hardware required (+/-)
\item All examples in \emph{one} design
\begin{itemize}
\item Results in a little bit more complex setup
\end{itemize}
\item Needs an Internet connection
\begin{itemize}
\item  Tests against latest Chisel version
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chisel Tutorial}
\begin{itemize}
\item Get the tutorial
\end{itemize}
\begin{chisel}
git clone https://github.com/ucb-bar/chisel-tutorial.git
cd chisel-tutorial
git checkout chisel2
\end{chisel}
\begin{itemize}
\item Test the installation with a Hello World
\end{itemize}
\begin{chisel}
cd hello
make
\end{chisel}
\begin{itemize}
\item May take some time
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Very Minimal Hello World}
\begin{chisel}
class Hello extends Module {
  val io = new Bundle { 
    val out = UInt(OUTPUT, 8)
  }
  io.out := UInt(42)
}
\end{chisel}
\begin{itemize}
\item Produces hardware for a single constant
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Testing the Minimal Hello World}
\begin{chisel}
class HelloTests(c: Hello) extends Tester(c) {
  step(1)
  expect(c.io.out, 42)
}
\end{chisel}
\begin{itemize}
\item Drive the simulation with \code{step(1)}, which is a single clock tick
\item Test output against expected value
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Tutorial Problems}
\begin{chisel}
cd problems
make Mux2.out
\end{chisel}
\begin{itemize}
\item This example should already work
\item Read the hardware description and test code
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Tutorial Problems}
\begin{chisel}
make Mux4.out
\end{chisel}
\begin{itemize}
\item The test should fail
\item Fix the Mux4 component so that the tests complete
\end{itemize}
\end{frame}

\begin{frame}[fragile]{More Problems}
\begin{itemize}
\item Explore more problems to solve
\item Suggestions:
\begin{itemize}
\item Accumulator
\item VecSchiftRegister (maybe)
\end{itemize}
\item Change the Blinking LED example so that
\begin{itemize}
\item It flashes for 1/5 second every second
\end{itemize}
\end{itemize}
\end{frame}



\end{document}