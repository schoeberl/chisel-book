\input{../slides/common/slides_common}

\newif\ifbook
\input{../shared/chisel}

% TikZ for diagrams
\usepackage{tikz}
\usetikzlibrary{positioning, arrows.meta}

% Optional visual tweaks
\tikzset{
    >=Stealth,
    every node/.style={rounded corners=2pt}
}

\title{Introduction to Chisel}
\author{Martin Schoeberl}
\date{\today}
\institute{Technical University of Denmark\\
Embedded Systems Engineering}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[fragile]{TODO}
\begin{itemize}
\item Copy from DE2 slides 2, maybe 3)
\item have a break and lab in the middle
\item Exercises from DE2
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Motivating Example:\\
Lipsi: Probably the Smallest Processor in the World}
\begin{itemize}
\item Tiny processor
\item Simple instruction set
\item Shall be small
\begin{itemize}
\item Around 200 logic cells, one FPGA memory block
\end{itemize}
\item Hardware described in Chisel
\item Available at \url{https://github.com/schoeberl/lipsi}
\item Usage
\begin{itemize}
\item Utility processor for small stuff
% \item Could be used for your vending machine
\item In teaching introduction to computer architecture
\end{itemize}
\item The design took place on the island of Lipsi
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The Design of Lipsi on Lipsi}
\begin{figure}
    \centering
    \includegraphics[scale=0.3]{../slides-tutorial/lipsi}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Lipsi Implementation}
\begin{itemize}
\item Hardware described in Chisel
\item Tester in Chisel/Scala
\item Assembler in Scala
\begin{itemize}
\item Core case statement about 20 lines
\end{itemize}
\item Reference design of Lipsi as a software simulator in Scala
\item Testing:
\begin{itemize}
\item Self-testing assembler programs
\item Comparing hardware with a software simulator
\end{itemize}
\item All in a single programming language!
\item All in a single program
\item How much work is this?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chisel is Productive}
\begin{itemize}
\item All coded and tested in less than 14 hours!
\end{itemize}
\begin{itemize}
\item The hardware in Chisel
\item Assembler in Scala
\item Some assembler programs (blinking LED)
\item Simulation in Scala
\item Two testers
\end{itemize}
\begin{itemize}
\item BUT, this does not include the design (done on paper)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Motivating Example: Lipsi, a Tiny Processor}
\begin{itemize}
\item Show in IntelliJ
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chisel}
\begin{itemize}
\item A hardware \emph{construction} language
\begin{itemize}
\item Constructing Hardware in a Scala Embedded Language
\item If it compiles, it is synthesizable hardware 
\item Say goodbye to your unintended latches
\end{itemize}
\item Chisel is not a high-level synthesis language
\item Single source for two targets
\begin{itemize}
\item Cycle accurate simulation (testing)
\item Verilog for synthesis
\end{itemize}
\item Embedded in Scala
\begin{itemize}
\item Full power of Scala available
\item We use Scala to write the generators
\end{itemize}
\item Developed at UC Berkeley
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The C Language Family}

\Tree[.C [
   [.{\bf Verilog} {\bf SystemVerilog} ]
   [.C++  \emph{SystemC}  ]
   [.Java [.Scala {\bf Chisel} ] ]
   [.C\# ] ] ]
 
\end{frame}

\begin{frame}[fragile]{Other Language Families}

\begin{columns}
\column{0.5\textwidth}
\begin{center}
\Tree[.Algol [.Ada [.{\bf VHDL} ] ] ]
\end{center}
\column{0.5\textwidth}
\begin{center}
\Tree[.Python [.{\bf MyHDL} ] ]
\end{center}
\end{columns}
\end{frame}

\begin{frame}[fragile]{A Small Language}
\begin{itemize}
\item Chisel is a \emph{small} language
\item On purpose
\item Not many constructs to remember
\item The \href{https://github.com/freechipsproject/chisel-cheatsheet/releases/latest/download/chisel_cheatsheet.pdf}{Chisel Cheatsheet} fits on two pages
\item The power comes with Scala for circuit generators
\item With Scala, Chisel can grow with you
\end{itemize}
\end{frame}


%\begin{frame}[fragile]{Example: 2-bit Counter}
%\begin{verbatim}
%class Counter extends Module {
%  val io = IO(new Bundle {
%    val out = Output(UInt(2.W))
%  })
%  val count = RegInit(0.U(2.W))
%  count := count + 1.U
%  io.out := count
%}
%\end{verbatim}
%\end{frame}
%
%\begin{frame}[fragile]{Example Test}
%\begin{verbatim}
%test(new Counter) { c =>
%  c.io.out.expect(0.U)
%  c.clock.step()
%  c.io.out.expect(1.U)
%  c.clock.step()
%  c.io.out.expect(2.U)
%}
%\end{verbatim}
%\end{frame}



\begin{frame}[fragile]{Tool Flow for Chisel Defined Hardware}
\begin{figure}
    \centering
    \includegraphics[scale=0.35]{../figures/flow}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Chisel is a Hardware Construction Language}
\begin{itemize}
\item The code looks much like Java code
\item But it is \emph{not} a program in the usual sense
\item It represents a circuit
\item The ``program'' constructs the circuit
\item All statements are ``executed'' in parallel
\item Statement order has \emph{mostly} no meaning
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A Chisel Book}
\begin{figure}
    \centering
    \href{https://github.com/schoeberl/chisel-book}{\includegraphics[scale=0.4]{../cover-small}}
\end{figure}

\begin{itemize}
\item Available in open access (\href{https://www.imm.dtu.dk/~masca/chisel-book.pdf}{as PDF})
\begin{itemize}
\item Optimized for reading on a tablet (size, hyperlinks)
\end{itemize}
\item Amazon can do the printout
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Chisel and Scala}
\begin{itemize}
\item Chisel is a library written in Scala
\begin{itemize}
\item Import the library with \code{import chisel3.\_}
\end{itemize}
\item Chisel code is Scala code
\item When it is run is \emph{generates} hardware
\begin{itemize}
\item Verilog for synthesis and siumulation
\end{itemize}
\item Chisel is an embedded domain-specific language
\item Two languages in one can be a little bit confusing
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chisel in Scala}
\begin{itemize}
\item Chisel components are Scala classes
\item Chisel code is in the constructor
\item Executed at object creation time
\item Builds the network of hardware objects
\item Testers are written in Scala to drive the tests
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Signal Types}
\begin{itemize}
\item All types in hardware are a collection of bits
\item The base type in Chisel is \code{Bits}
\item \code{UInt} represents an unsigned integer
\item \code{SInt} represents a signed integer (in two's complement)
\end{itemize}
\shortlist{../code/types.txt}
\end{frame}

\begin{frame}[fragile]{Number of Bits: n.W}
\begin{itemize}
\item A collection of bits has a \emph{width}
\item The width is the number of bits
\item Is written as number followed by \code{.W}
\item Following example shows the width of \code{n}
\end{itemize}
\shortlist{../code/n_w.txt}
\end{frame}

\begin{frame}[fragile]{Constants}
\begin{itemize}
\item Constants can represent signed or unsigned numbers
\item We use \code{.U} and \code{.S} to distinguish
\end{itemize}
\shortlist{../code/constants.txt}
\begin{itemize}
\item Constants can also be specified with a width
\end{itemize}
\shortlist{../code/const_width.txt}
\end{frame}

\begin{frame}[fragile]{Hexadecimal and Binary Representation}
\begin{itemize}
\item We can specify constants with a different base
\item May come handy sometimes
\end{itemize}
\shortlist{../code/const_base.txt}
\end{frame}

\begin{frame}[fragile]{Boolean Values}
\begin{itemize}
\item Type for logical values
\item Can be \code{true} or \code{false}
\item Almost exchangeable with \code{UInt(1.W)}
\item Sometimes a signal, such as \code{valid}, may be better represented by a Boolean type
\end{itemize}
\shortlist{../code/bool.txt}
\end{frame}

\begin{frame}[fragile]{Combinational Circuits}
\begin{itemize}
\item Chisel uses Boolean operators, similar to C or Java
\item \code{\&} is the AND operator and \code{|} is the OR operator
\item The following code is the same as the schematics
\item \code{val logic} gives the circuit/expression the name \code{logic}
\item That name can be used in following expressions
\end{itemize}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/logic}
\end{figure}
\shortlist{../code/logic.txt}
\end{frame}

\begin{frame}[fragile]{Combinational Circuits}
\begin{itemize}
\item Simple expressions represent a circuit tree
\item Arbitrary directed acyclic graphs need named subexpressions
\item Using Scala's \code{val} keyword for variables that don't change
\item Referenced multiple times
\end{itemize}
\begin{chisel}
val cond = a & b
val result = (cond & selA) | (!cond & selB)
\end{chisel}
\end{frame}



\begin{frame}[fragile]{Standard Logic Operations}
\shortlist{../code/bool_ops.txt}
\begin{itemize}
\item Note that we do not need to define the width of the values
\item Note also that this is \emph{hardware}
\item All expressions are evaluated in parallel
\item Order does not matter
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Arithmetic Operations}
\begin{itemize}
\item Same as in Java or C
\item The width of the result is automatically computed
\item E.g., the width of the multiplication is the sum of the width of \code{a} and the width of \code{b} 
\end{itemize}
\shortlist{../code/arith_ops.txt}
\end{frame}

\begin{frame}[fragile]{Comparison}
\begin{itemize}
\item The usual operations
\begin{itemize}
\item Unusual equal and unequal operator symbols
\item To keep the original Sala operators usable for references
\end{itemize}
\item Operands are \code{UInt} and \code{SInt}
\item Operands can be \code{Bool} for equal and unequal
\item Result is \code{Bool}
\end{itemize}
\begin{chisel}
===, =/=
>, >=, <, <=
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Boolean Logical Operations}
\begin{itemize}
\item Operands and result are \code{Bool}
\item Logical NOT, AND, and OR
\end{itemize}
\begin{chisel}
val notX = !x
val bothTrue = a && b
val orVal = x || y
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Chisel Defined Hardware Operators}
\begin{table}
{\footnotesize
  \begin{tabular}{lll}
    \toprule
    Operator & Description & Data types \\
    \midrule
    \code{* / \%} & multiplication, division, modulus & UInt, SInt \\
    \code{+ -} & addition, subtraction & UInt, SInt \\
    \code{=== =/=} & equal, not equal & UInt, SInt, returns Bool \\
    \code{> >= < <=} & comparison & UInt, SInt, returns Bool \\
    \code{<< >>} & shift left, shift right (sign extend on SInt) & UInt, SInt \\
    \code{\~} & NOT & UInt, SInt, Bool \\
    \code{\& | \^} & AND, OR, XOR & UInt, SInt, Bool \\
    \code{!} & logical NOT & Bool \\
    \code{\&\& ||} & logical AND, OR & Bool \\
    \bottomrule 
  \end{tabular} 
  }
\end{table}
\end{frame}

\begin{frame}[fragile]{Wires}
\begin{itemize}
\item A signal (or wire) can be first defined
\item And later assigned an expression with \code{:=}
\end{itemize}
\shortlist{../code/wire.txt}
\end{frame}

\begin{frame}[fragile]{Connections}
\begin{itemize}
\item Connections with the \code{:=} assignment
\item When \emph{reassigning} a value to a wire, port, or register
\begin{chisel}
  adder.io.a := ina
  adder.io.b := inb
\end{chisel}
%\item Automatic bulk connections between components
%\begin{chisel}
%  dec.io <> exe.io
%  mem.io <> exe.io
%\end{chisel}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Subfields and Concatenation}
A single bit can be extracted as follows:
\shortlist{../code/single_bit.txt}

\noindent A subfield can be extracted from end to start position:
\shortlist{../code/sub_field.txt}

\noindent Bit fields are concatenated with the \code{\#\#} operator:
\shortlist{../code/concat.txt}
\end{frame}


\begin{frame}[fragile]{A Multiplexer}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/mux}
\end{figure}
\begin{itemize}
\item A Multiplexer selects between alternatives
\item So common that Chisel provides a construct for it
\item Selects \code{a} when \code{sel} is \code{true.B} otherwise \code{b}
\end{itemize}
\shortlist{../code/mux.txt}
\end{frame}

\begin{frame}[fragile]{Conditional Update}
\begin{itemize}
\item With \code{when} we can express a conditional update
\item The resulting circuit is a multiplexer
\item In contrast to the \code{Mux} component, we can have several assignments in the \code{when} block
\item The rule is the the last enabled assignment counts
\begin{itemize}
\item Here the order of statements has a meaning
\end{itemize}
\end{itemize}
\shortlist{../code/comb_wire.txt}
\end{frame}

\begin{frame}[fragile]{Conditional Updates for Combinational Circuits}
\shortlist{../code/comb_elsewhen.txt}
\begin{itemize}
\item Similar to VHDL \code{process} or SystemVerilog \code{always\_comb}
\item Chisel checks for complete assignments in all branches
\item Latches give compile error
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chained Conditionals}
\begin{itemize}
\item Chain of conditionals with \code{.elsewhen}
\item With an optional \emph{else} path with \code{.otherwise}
\item Note that Scala has \code{if/else}
\begin{itemize}
\item Does NOT result in hardware
\item Are used to conditionally \emph{generate} hardware
\item We will look at this later
\end{itemize}
\item Note the ``.'' at the operators
\end{itemize}
\begin{chisel}
  when (c1) { v := 1.U }
  .elsewhen (c2) { v := 2.U }
  .otherwise { v := 3.U }
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Switch Statement}
\begin{itemize}
\item Series of comparisons
\item Chisel allows combinational logic be updated conditionally 
\item Chisel disallows incomplete specified logic (= latches)
\item Chisel will report a runtime error
\end{itemize}
\begin{chisel}
  switch(fn) {
    is(0.U) { result := a + b }
    is(1.U) { result := a - b }
    is(2.U) { result := a | b }
    is(3.U) { result := a & b }
  }
\end{chisel}
\end{frame}


\begin{frame}[fragile]{The World of Combinational Logic}
\begin{itemize}
\item With the shown operations (logic, arithmetic, Mux) all possible combinational circuits can be described
\item Even the \code{Mux} is already \emph{syntactic sugar}
\begin{itemize}
\item A \code{Mux} is basically: \code{(a \& sel) | (b \& !sel)}
\end{itemize}
\item But Chisel provides further constructs for more elegant description of circuits
\item Stay tuned!
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Register}
\begin{itemize}
\item State elements
\item Positive edge triggered D flip-flop(s)
\item A register is a collection of flip-flops
\item May be set to a value on reset
\item Clock and reset are implicitly connected to the register
\item A register can be any Chisel type that can be represented as a collection of bits
\end{itemize}
\begin{chisel}
val q = RegNext(d)
\end{chisel}
\begin{itemize}
\item \code{d} is the input, \code{q} the output
\item Register type is inferred by the input (d) type
\end{itemize}
\end{frame}



\begin{frame}[fragile]{A Register with Reset}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/register-reset-0}
\end{figure}
\end{frame}


\begin{frame}[fragile]{A Register with Reset}
Following code defines an 8-bit register, initialized with 0 at reset:
\shortlist{../code/register.txt}
\noindent An input is connected to the register with the \code{:=} update operator and
the output of the register can be used just with the name in an expression:
\shortlist{../code/reg_con.txt}
\end{frame}



\begin{frame}[fragile]{Hello World in Chisel}
\shortlist{../code/hello.txt}
\end{frame}

\begin{frame}[fragile]{Chisel is a Hardware Construction Language}
\begin{itemize}
\item The code I showed you looks much like Java code
\item But it is \emph{not} a program in the usual sense
\item It represents a circuit
\item The ``program'' constructs the circuit
\item All statements are ``executed'' in parallel
\item Statement order has \emph{mostly} no meaning
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Maybe here is Time for the break and lab}
\begin{itemize}
\item abc
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Data Aggregation with Bundles}
\begin{itemize}
\item A \code{Bundle} groups several named fields
\item Like a C struct or VHDL record
\item \code{Vec} is a vector of elements with the same type
\item Can be arbitrary mixed
\end{itemize}
\begin{chisel}
class AluFields extends Bundle {
  val function = UInt(2.W)
  val inputA = UInt(8.W)
  val inputB = UInt(8.W)
  val result = UInt(8.W)
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Vectors}
\begin{itemize}
\item Indexable vector of elements
\item Elements can be Chisel basic elements, or bundles
\item Type is specified as second parameter
\end{itemize}
\begin{chisel}
val myVec = Vec(3, SInt(10.W))
val y = myVec(2)
myVec(0) := -3.S
\end{chisel}
\begin{itemize}
\item A register file as a register of a vector
\end{itemize}
\begin{chisel}
val vecReg = Reg(Vec(32, SInt(32.W)))
\end{chisel}
\end{frame}

\begin{frame}[fragile]{IO Ports}
\begin{chisel}
class Channel extends Bundle {
  val data = Input(UInt(8.W))
  val ready = Output(Bool())
  val valid = Input(Bool())
}
\end{chisel}
\begin{itemize}
\item Ports are Bundles with directions
\item Ports are used to connect modules
\item Can be reversed with the \code{Flipped}
\item Convenient to have one bundle definition working as a source
and the destination used between two modules
\end{itemize}
\begin{chisel}
class ChannelUsage extends Bundle {
  val input = new Channel()
  val output = Flipped(new Channel())
}
\end{chisel}
\end{frame}


\begin{frame}[fragile]{Modules}
\begin{itemize}
\item Modules are used to organize the circuit
\item Similar to VHDL components (entity/architecture)
\item A class that inherits from \code{Module}
\item Circuit description in the constructor
\item Interface (port) is a \code{Bundle}, wrapped into an \code{IO()}, and stored in the field \code{io}
\end{itemize}
\begin{chisel}
class Adder extends Module {
  val io = IO(new Bundle {
    val a = Input(UInt(4.W))
    val b = Input(UInt(4.W))
    val result = Output(UInt(4.W))
  })

  val addVal = io.a + io.b
  io.result := addVal
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Module Usage}
\begin{itemize}
\item Create with \code{new} and wrap into a \code{Module()}
\item Interface port via the \code{io} field
\item Note the assignment operator \code{:=} on \code{io} fields
\end{itemize}
\begin{chisel}
  val adder = Module(new Adder())
  adder.io.a := ina
  adder.io.b := inb
  val result = adder.io.result
\end{chisel}
\end{frame}

%\begin{frame}[fragile]{A Small Circuit}
%\begin{itemize}
%\item Our Chisel knowledge is complete enough\\ to implement any digital circuit
%\item Maybe not in the most elegant way ;-)
%\item A counter is a simple basic component
%\item The following counts form 0 to 100
%\end{itemize}
%\begin{chisel}
%  val cntReg = RegInit(0.U(8.W))
%
%  cntReg := Mux(cntReg === 100.U,
%    0.U, cntReg + 1.U)
%\end{chisel}
%\end{frame}
%
%\begin{frame}[fragile]{The Complete Counter Module}
%\begin{chisel}
%class Counter extends Module {
%  val io = IO(new Bundle {
%    val cnt = Output(UInt(8.W))
%  })
%
%  val cntReg = RegInit(0.U(8.W))
%
%  cntReg := Mux(cntReg === 100.U,
%    0.U, cntReg + 1.U)
%
%  io.cnt := cntReg
%}
%\end{chisel}
%\end{frame}

\begin{frame}[fragile]{Chisel Main}

\begin{itemize}
\item Create one top-level Module
\item Invoke the Verilog emitter from the Scala \code{main} (or App)
\item Following code generates Verilog code
\end{itemize}
\shortlist{../code/generate.txt}
\end{frame}

%\begin{frame}[fragile]{Generic Components}
%\begin{chisel}
%val c = Mux(cond, a, b)
%\end{chisel}
%\begin{itemize}
%\item This is a multiplexer
%\item Input can be any type
%\end{itemize}
%\end{frame}


\begin{frame}[fragile]{Testing with Chisel}
\begin{itemize}
\item A test contains:
\begin{itemize}
\item a device under test (DUT) and
\item the testing logic
\end{itemize}
\item Set input values with \code{poke}
\item Advance the simulation with \code{step}
\item Read the output values with \code{peek}
\item Compare the values with \code{expect}
\item Import following packages:
\shortlist{../code/test_import.txt}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{An Example DUT}
\begin{itemize}
\item A device-under test (DUT)
\item Just 2-bit AND logic
\shortlist{../code/test_dut.txt}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A ChiselTest}
\begin{itemize}
\item Extends class \code{AnyFlatSpec} with \code{ChiselScalatestTester}
\item Has the device-under test (DUT) as parameter of the \code{test} function
\item Test function contains the test code
\item Testing code can use all features of Scala
\end{itemize}
\end{frame}

%\begin{frame}[fragile]{A Simple Tester}
%\begin{itemize}
%\item Just using \code{println} for manual inspection
%\shortlist{../code/test_bench_simple.txt}
%\end{itemize}
%\end{frame}


\begin{frame}[fragile]{A Test}
\begin{itemize}
\item Poke values and \code{expect} some output
\shortlist{../code/test_bench.txt}
\end{itemize}
\end{frame}

%\begin{frame}[fragile]{Testing}
%\begin{itemize}
%\item Within Chisel with a tester (= Scala program)
%\item May include waveform generation
%\item peek and poke to read and set values
%\begin{itemize}
%\item Remember the BASIC days ;-)
%\end{itemize}
%\item printf in simulation on rising edge
%\begin{chisel}
%printf("Counting %x\n", r1)
%\end{chisel}
%\end{itemize}
%\end{frame}
%
%\begin{frame}[fragile]{Testing Example}
%\shortlist{../code/test_bench_simple.txt}
%\end{frame}




\begin{frame}[fragile]{Summary}
\begin{itemize}
\item xxx
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Lab 2}
\begin{itemize}
\item I assume that you installed all tools and did lab0 and lab1 last week
%\item Code is in \href{https://github.com/schoeberl/agile-hw/tree/main/lab1}{lab1}
\end{itemize}
\end{frame}

\end{document}

\begin{frame}[fragile]{Title}
\begin{itemize}
\item abc
\end{itemize}
\end{frame}
