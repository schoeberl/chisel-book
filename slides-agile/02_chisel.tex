\input{../slides/common/slides_common}

\newif\ifbook
\input{../shared/chisel}

% TikZ for diagrams
\usepackage{tikz}
\usetikzlibrary{positioning, arrows.meta}

% Optional visual tweaks
\tikzset{
    >=Stealth,
    every node/.style={rounded corners=2pt}
}

\title{Introduction to Chisel}
\author{Martin Schoeberl}
\date{\today}
\institute{Technical University of Denmark\\
Embedded Systems Engineering}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[fragile]{Motivating Example:\\
Lipsi: Probably the Smallest Processor in the World}
\begin{itemize}
\item Tiny processor
\item Simple instruction set
\item Shall be small
\begin{itemize}
\item Around 200 logic cells, one FPGA memory block
\end{itemize}
\item Hardware described in Chisel
\item Available at \url{https://github.com/schoeberl/lipsi}
\item Usage
\begin{itemize}
\item Utility processor for small stuff
% \item Could be used for your vending machine
\item In teaching introduction to computer architecture
\end{itemize}
\item The design took place on the island of Lipsi
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The Design of Lipsi on Lipsi}
\begin{figure}
    \centering
    \includegraphics[scale=0.3]{../slides-tutorial/lipsi}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Lipsi Implementation}
\begin{itemize}
\item Hardware described in Chisel
\item Tester in Chisel/Scala
\item Assembler in Scala
\begin{itemize}
\item Core case statement about 20 lines
\end{itemize}
\item Reference design of Lipsi as a software simulator in Scala
\item Testing:
\begin{itemize}
\item Self-testing assembler programs
\item Comparing hardware with a software simulator
\end{itemize}
\item All in a single programming language!
\item All in a single program
\item How much work is this?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chisel is Productive}
\begin{itemize}
\item All coded and tested in less than 14 hours!
\end{itemize}
\begin{itemize}
\item The hardware in Chisel
\item Assembler in Scala
\item Some assembler programs (blinking LED)
\item Simulation in Scala
\item Two testers
\end{itemize}
\begin{itemize}
\item BUT, this does not include the design (done on paper)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Motivating Example: Lipsi, a Tiny Processor}
\begin{itemize}
\item Show in IntelliJ
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chisel}
\begin{itemize}
\item A hardware \emph{construction} language
\begin{itemize}
\item Constructing Hardware in a Scala Embedded Language
\item If it compiles, it is synthesizable hardware 
\item Say goodbye to your unintended latches
\end{itemize}
\item Chisel is not a high-level synthesis language
\item Single source for two targets
\begin{itemize}
\item Cycle accurate simulation (testing)
\item Verilog for synthesis
\end{itemize}
\item Embedded in Scala
\begin{itemize}
\item Full power of Scala available
\item We use Scala to write the generators
\end{itemize}
\item Developed at UC Berkeley
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The C Language Family}

\Tree[.C [
   [.{\bf Verilog} {\bf SystemVerilog} ]
   [.C++  \emph{SystemC}  ]
   [.Java [.Scala {\bf Chisel} ] ]
   [.C\# ] ] ]
 
\end{frame}

\begin{frame}[fragile]{Other Language Families}

\begin{columns}
\column{0.5\textwidth}
\begin{center}
\Tree[.Algol [.Ada [.{\bf VHDL} ] ] ]
\end{center}
\column{0.5\textwidth}
\begin{center}
\Tree[.Python [.{\bf MyHDL} ] ]
\end{center}
\end{columns}
\end{frame}

\begin{frame}[fragile]{A Small Language}
\begin{itemize}
\item Chisel is a \emph{small} language
\item On purpose
\item Not many constructs to remember
\item The \href{https://github.com/freechipsproject/chisel-cheatsheet/releases/latest/download/chisel_cheatsheet.pdf}{Chisel Cheatsheet} fits on two pages
\item The power comes with Scala for circuit generators
\item With Scala, Chisel can grow with you
\end{itemize}
\end{frame}


%\begin{frame}[fragile]{Example: 2-bit Counter}
%\begin{verbatim}
%class Counter extends Module {
%  val io = IO(new Bundle {
%    val out = Output(UInt(2.W))
%  })
%  val count = RegInit(0.U(2.W))
%  count := count + 1.U
%  io.out := count
%}
%\end{verbatim}
%\end{frame}
%
%\begin{frame}[fragile]{Example Test}
%\begin{verbatim}
%test(new Counter) { c =>
%  c.io.out.expect(0.U)
%  c.clock.step()
%  c.io.out.expect(1.U)
%  c.clock.step()
%  c.io.out.expect(2.U)
%}
%\end{verbatim}
%\end{frame}



\begin{frame}[fragile]{Tool Flow for Chisel Defined Hardware}
\begin{figure}
    \centering
    \includegraphics[scale=0.35]{../figures/flow}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Chisel is a Hardware Construction Language}
\begin{itemize}
\item The code looks much like Java code
\item But it is \emph{not} a program in the usual sense
\item It represents a circuit
\item The ``program'' constructs the circuit
\item All statements are ``executed'' in parallel
\item Statement order has \emph{mostly} no meaning
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A Chisel Book}
\begin{figure}
    \centering
    \href{https://github.com/schoeberl/chisel-book}{\includegraphics[scale=0.4]{../cover-small}}
\end{figure}

\begin{itemize}
\item Available in open access (\href{https://www.imm.dtu.dk/~masca/chisel-book.pdf}{as PDF})
\begin{itemize}
\item Optimized for reading on a tablet (size, hyperlinks)
\end{itemize}
\item Amazon can do the printout
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Chisel and Scala}
\begin{itemize}
\item Chisel is a library written in Scala
\begin{itemize}
\item Import the library with \code{import chisel3.\_}
\end{itemize}
\item Chisel code is Scala code
\item When it is run is \emph{generates} hardware
\begin{itemize}
\item Verilog for synthesis and simulation
\end{itemize}
\item Chisel is an embedded domain-specific language
\item Two languages in one can be a little bit confusing
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chisel in Scala}
\begin{itemize}
\item Chisel components are Scala classes
\item Chisel code is in the constructor
\item Executed at object creation time
\item Builds the network of hardware objects
\item Testers are written in Scala to drive the tests
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Signal Types}
\begin{itemize}
\item All types in hardware are a collection of bits
\item The base type in Chisel is \code{Bits}
\item \code{UInt} represents an unsigned integer
\item \code{SInt} represents a signed integer (in two's complement)
\end{itemize}
\shortlist{../code/types.txt}
\end{frame}

\begin{frame}[fragile]{Number of Bits: n.W}
\begin{itemize}
\item A collection of bits has a \emph{width}
\item The width is the number of bits
\item Is written as number followed by \code{.W}
\item Following example shows the width of \code{n}
\end{itemize}
\shortlist{../code/n_w.txt}
\end{frame}

\begin{frame}[fragile]{Constants}
\begin{itemize}
\item Constants can represent signed or unsigned numbers
\item We use \code{.U} and \code{.S} to distinguish
\end{itemize}
\shortlist{../code/constants.txt}
\begin{itemize}
\item Constants can also be specified with a width
\end{itemize}
\shortlist{../code/const_width.txt}
\end{frame}

\begin{frame}[fragile]{Hexadecimal and Binary Representation}
\begin{itemize}
\item We can specify constants with a different base
\item May come handy sometimes
\end{itemize}
\shortlist{../code/const_base.txt}
\end{frame}

\begin{frame}[fragile]{Boolean Values}
\begin{itemize}
\item Type for logical values
\item Can be \code{true} or \code{false}
\item Almost exchangeable with \code{UInt(1.W)}
\item Sometimes a signal, such as \code{valid}, may be better represented by a Boolean type
\end{itemize}
\shortlist{../code/bool.txt}
\end{frame}

\begin{frame}[fragile]{Combinational Circuits}
\begin{itemize}
\item Chisel uses Boolean operators, similar to C or Java
\item \code{\&} is the AND operator and \code{|} is the OR operator
\item The following code is the same as the schematics
\item \code{val logic} gives the circuit/expression the name \code{logic}
\item That name can be used in following expressions
\end{itemize}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/logic}
\end{figure}
\shortlist{../code/logic.txt}
\end{frame}

\begin{frame}[fragile]{Combinational Circuits}
\begin{itemize}
\item Simple expressions represent a circuit tree
\item Arbitrary directed acyclic graphs need named subexpressions
\item Using Scala's \code{val} keyword for variables that don't change
\item Referenced multiple times
\end{itemize}
\begin{chisel}
val cond = a & b
val result = (cond & selA) | (!cond & selB)
\end{chisel}
\end{frame}



\begin{frame}[fragile]{Standard Logic Operations}
\shortlist{../code/bool_ops.txt}
\begin{itemize}
\item Note that we do not need to define the width of the values
\item Note also that this is \emph{hardware}
\item All expressions are evaluated in parallel
\item Order does not matter
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Arithmetic Operations}
\begin{itemize}
\item Same as in Java or C
\item The width of the result is automatically computed
\item E.g., the width of the multiplication is the sum of the width of \code{a} and the width of \code{b} 
\end{itemize}
\shortlist{../code/arith_ops.txt}
\end{frame}

\begin{frame}[fragile]{Comparison}
\begin{itemize}
\item The usual operations (as in Java or C)
\begin{itemize}
\item Unusual equal and unequal operator symbols
\item To keep the original Sala operators usable for references
\end{itemize}
\item Operands are \code{UInt} and \code{SInt}
\item Operands can be \code{Bool} for equal and unequal
\item Result is \code{Bool}
\end{itemize}
\begin{chisel}
>, >=, <, <=
===, =/=
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Boolean Logical Operations}
\begin{itemize}
\item Operands and result are \code{Bool}
\item Logical NOT, AND, and OR
\end{itemize}
\begin{chisel}
val notX = !x
val bothTrue = a && b
val orVal = x || y
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Chisel Defined Hardware Operators}
\begin{table}
{\footnotesize
  \begin{tabular}{lll}
    \toprule
    Operator & Description & Data types \\
    \midrule
    \code{* / \%} & multiplication, division, modulus & UInt, SInt \\
    \code{+ -} & addition, subtraction & UInt, SInt \\
    \code{=== =/=} & equal, not equal & UInt, SInt, returns Bool \\
    \code{> >= < <=} & comparison & UInt, SInt, returns Bool \\
    \code{<< >>} & shift left, shift right (sign extend on SInt) & UInt, SInt \\
    \code{\~} & NOT & UInt, SInt, Bool \\
    \code{\& | \^} & AND, OR, XOR & UInt, SInt, Bool \\
    \code{!} & logical NOT & Bool \\
    \code{\&\& ||} & logical AND, OR & Bool \\
    \bottomrule 
  \end{tabular} 
  }
\end{table}
\end{frame}


\begin{frame}[fragile]{Wires}
\begin{itemize}
\item A signal (or wire) can be first defined
\item And later assigned an expression with \code{:=}
\end{itemize}
\shortlist{../code/wire.txt}
\end{frame}

\begin{frame}[fragile]{Connections}
\begin{itemize}
\item Connections with the \code{:=} assignment
\item When \emph{reassigning} a value to a wire, port, or register
\begin{chisel}
  adder.io.a := ina
  adder.io.b := inb
\end{chisel}
%\item Automatic bulk connections between components
%\begin{chisel}
%  dec.io <> exe.io
%  mem.io <> exe.io
%\end{chisel}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Subfields and Concatenation}
A single bit can be extracted as follows:
\shortlist{../code/single_bit.txt}

\noindent A subfield can be extracted from end to start position:
\shortlist{../code/sub_field.txt}

\noindent Bit fields are concatenated with the \code{\#\#} operator:
\shortlist{../code/concat.txt}
\end{frame}


\begin{frame}[fragile]{A Multiplexer}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/mux}
\end{figure}
\begin{itemize}
\item A Multiplexer selects between alternatives
\item So common that Chisel provides a construct for it
\item Selects \code{a} when \code{sel} is \code{true.B} otherwise \code{b}
\end{itemize}
\shortlist{../code/mux.txt}
\end{frame}

\begin{frame}[fragile]{Combinational Circuit with Conditional Update}
\begin{itemize}
\item Value first needs to be wrapped into a \code{Wire}
\item Updates with the Chisel update operation \code{:=}
\item With \code{when} we can express a conditional update
\item The condition is an expression with a Boolean result
\item The resulting circuit is a multiplexer
\item The rule is that the last enabled assignment counts
\begin{itemize}
\item Here the order of statements has a meaning
\end{itemize}
\end{itemize}
\shortlist{../code/comb_wire2.txt}
\end{frame}

\begin{frame}[fragile]{The ``Else'' Branch}
\begin{itemize}
\item We can express a form of ``else''
\item Note the \code{.} in \code{.otherwise}
\end{itemize}
\shortlist{../code/comb_otherwise.txt}
\end{frame}



\begin{frame}[fragile]{A Chain of Conditions}
\begin{itemize}
\item To test for different conditions
\item Select with a priority order
\item The first that is true counts
\item The hardware is a chain of multiplexers
\end{itemize}
\begin{columns}
\column{0.5\textwidth}
\shortlist{../code/comb_elsewhen.txt}
\column{0.5\textwidth}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/mux-chain}
\end{figure}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Default Assignment}
\begin{itemize}
\item Practical for complex expressions
\item Forgetting to assign a value at all conditions
\begin{itemize}
\item Would describe a latch
\item Runtime error in Chisel
\end{itemize}
\item Assign a default value is a good practice
\end{itemize}
\shortlist{../code/comb_wiredefault.txt}
\end{frame}

\begin{frame}[fragile]{Logic Can Be Expressed as a Table}
\begin{itemize}
\item Sometimes more convenient 
\item Still combinational logic (gates)
\item Is converted to Boolean expressions
\item Let the synthesis tool do the conversion!
\item We use the \code{switch} statement
\end{itemize}
\shortlist{../code/encdec_decbin.txt}
\end{frame}



\begin{frame}[fragile]{The World of Combinational Logic}
\begin{itemize}
\item With the shown operations (logic, arithmetic, Mux) all possible combinational circuits can be described
\item Even the \code{Mux} is already \emph{syntactic sugar}
\begin{itemize}
\item A \code{Mux} is basically: \code{(a \& sel) | (b \& !sel)}
\end{itemize}
\item But Chisel provides further constructs for more elegant description of circuits
\item Stay tuned!
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Lab 2}
\begin{itemize}
\item Combinational circuits in Chisel
\item \href{https://github.com/schoeberl/chisel-lab/tree/master/lab2}{Chisel Lab 2 Page}
\item Each exercise contains a test, which initially fails
\item \code{sbt test} runs them all
\begin{itemize}
\item To just run a single test, run e.g.,\\
\code{sbt "testOnly MajorityPrinter"}
\end{itemize}
When all test succeed you're done ;-)
\item Components contain a comment where you shall add your implementation
\item The initial majority example has an optional implementation in an FPGA
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sequential Building Blocks}
\begin{itemize}
\item Contain a register
\item Plus combinational circuits
\end{itemize}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/register}
\end{figure}
\shortlist{../code/sequ_reg.txt}
\end{frame}

\begin{frame}[fragile]{Register With Reset}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/register-reset}
\end{figure}
\shortlist{../code/sequ_reg_init.txt}
\end{frame}

\begin{frame}[fragile]{Timing Diagram of the Register with Reset}
\begin{figure}
  \includegraphics[scale=1]{../figures/reg_wave}
\end{figure}
\begin{itemize}
\item Also called waveform diagram
\item Logic function over time
\item Can be used to describe a circuit function
\item Useful for debugging
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Register with Enable}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/register-enable}
\end{figure}
\begin{itemize}
\item Only when \code{enable} true is a value is stored
\end{itemize}
\shortlist{../code/sequ_reg_ena.txt}

\end{frame}

\begin{frame}[fragile]{A Register with Reset and Enable}
\begin{itemize}
\item We can combine initialization and enable
\end{itemize}
\shortlist{../code/sequ_reg_init_ena.txt}
\begin{itemize}
\item A register can also be part of an expression
\item What does the following circuit do?
\end{itemize}
\shortlist{../code/sequ_reg_rising.txt}
\end{frame}


\begin{frame}[fragile]{A Register with an Adder is a Counter}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/counter}
\end{figure}
\begin{itemize}
\item Is a free running counter
\item 0, 1, ... 14, 15, 0, 1, ...
\end{itemize}
\shortlist{../code/sequ_free_counter.txt}
\end{frame}


\begin{frame}[fragile]{A Counter with a Mux}
\shortlist{../code/counter.txt}
\begin{itemize}
\item This counter counts from 0 to 9
\item And starts from 0 again after reaching 9
\begin{itemize}
\item Starting from 0 is common in computer engineering
\end{itemize}
\item A counter is the hardware version of a \emph{for loop}
\item Often needed
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Counting Events}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/event-counter}
\end{figure}
\shortlist{../code/sequ_event_counter.txt}
\end{frame}


\begin{frame}[fragile]{Counting Up and Down}
\begin{itemize}
\item Up:
\shortlist{../code/when_counter.txt}
\item Down:
\shortlist{../code/down_counter.txt}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Hello World in Chisel}
\shortlist{../code/hello.txt}
\end{frame}

\begin{frame}[fragile]{Reminder: We Construct Hardware}
\begin{itemize}
\item Chisel code looks much like Java code
\item But it is \emph{not} a program in the usual sense
\item It represents a circuit
\item We should be able to \emph{draw} that circuit
\item The ``program'' constructs the circuit
\item All statements are ``executed'' in parallel
\item Statement order has mostly no meaning
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Structure With Bundles}
\begin{itemize}
\item A \code{Bundle} to group signals
\item Can be different types
\item Defined by a class that extends \code{Bundle}
\item Named fields as \code{val}s within the block
\item Like a C struct or VHDL record
\end{itemize}
\shortlist{../code/bundle.txt}
\end{frame}

\begin{frame}[fragile]{Using a Bundle}
\begin{itemize}
\item Create it with \code{new}
\item Wrap it into a \code{Wire}
\item Field access with \emph{dot} notation
\end{itemize}
\shortlist{../code/bundle_use.txt}
\end{frame}

\begin{frame}[fragile]{Wire, Reg, and IO}
\begin{itemize}
\item \code{UInt}, \code{SInt}, and \code{Bits} are Chisel types, not hardware
\item \code{Wire}, \code{Reg}, or \code{IO} generates hardware
\begin{itemize}
\item A \code{Wire} is a combinational circuit
\item A \code{Reg} is a register
\item A \code{IO} is a connection/port (for a module)
\end{itemize}
\item Can wrap any Chisel type, also \code{Bundle} or \code{Vec}
\item Give it a name by assigning it to a \code{val}
\end{itemize}
\shortlist{../code/wire_reg.txt}
\end{frame}

\begin{frame}[fragile]{Using = or :=}
\begin{itemize}
\item Later assign or reassign a value or expression with \code{:=}
\end{itemize}
\shortlist{../code/wire_reg_reassign.txt}
\begin{itemize}
\item Note the small difference between \code{=} and \code{:=}
\begin{itemize}
\item May be confusing to start with
\end{itemize}
\item Use \code{=} when \emph{creating} a hardware object to give it a name
\item Use \code{:=} when assigning or reassigning to an \emph{existing} hardware object
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Vectors}
\begin{itemize}
\item Indexable vector of elements
\item Elements can be Chisel basic elements, or bundles
\item Type is specified as second parameter
\end{itemize}
\begin{chisel}
val myVec = Vec(3, SInt(10.W))
val y = myVec(2)
myVec(0) := -3.S
\end{chisel}
\begin{itemize}
\item A register file as a register of a vector
\end{itemize}
\begin{chisel}
val vecReg = Reg(Vec(32, SInt(32.W)))
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Components/Modules}
\begin{itemize}
\item Components/Modules are building blocks
\begin{itemize}
\item Component and module are two names for the same thing
\end{itemize}
\item Components have input and output ports (= pins)
\begin{itemize}
\item Organized as a \code{Bundle}
\item Wrapped into an \code{IO()}
\item assigned to a field \code{io}
\end{itemize}
\item We build circuits as a hierarchy of components
\item In Chisel a component is called \code{Module}
\item Components/Modules are used to organize the circuit
\begin{itemize}
\item Similar to classes and methods in Java
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Input/Output Ports}
\begin{itemize}
\item Ports are the \emph{interface} to a module
\item Ports are bundles with directions
\item Ports are used to connect modules
\end{itemize}
\begin{chisel}
class AluIO extends Bundle {
  val function = Input(UInt(2.W))
  val inputA = Input(UInt(4.W))
  val inputB = Input(UInt(4.W))
  val result = Output(UInt(4.W))
}
\end{chisel}
\end{frame}


\begin{frame}[fragile]{An Adder Module}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/components-adder}
\end{figure}
\begin{itemize}
\item Practically too simple, but for the slides
\end{itemize}
\end{frame}

\begin{frame}[fragile]{An Adder Module}
\begin{itemize}
\item A \code{class} that \code{extends} \code{Module}
\item Interface (port) is a \code{Bundle}, wrapped into an \code{IO()}, and stored in the field \code{io}
\item Circuit description in the constructor
\end{itemize}
\shortlist{../code/components_add.txt}
\end{frame}


\begin{frame}[fragile]{An Register Module}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/components-register}
\end{figure}
\begin{itemize}
\item Practically too simple, but for the slides
\end{itemize}
\end{frame}

\begin{frame}[fragile]{An Register Module}
\shortlist{../code/components_reg.txt}
\end{frame}


\begin{frame}[fragile]{An Counter out of  Modules}
\begin{figure}
  \includegraphics[scale=\scale]{../figures/components-counter}
\end{figure}
\end{frame}

\begin{frame}[fragile]{An Counter out of  Modules}
\shortlist{../code/components_cnt.txt}
\end{frame}

\begin{frame}[fragile]{Using Modules/Components}
\begin{itemize}
\item Create with \code{new} and wrap into a \code{Module()}
\item Interface port via the \code{io} field
\item Note the assignment operator \code{:=} on \code{io} fields
\item Note the dot access to the field \code{io} and then the IO field
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Chisel Main}

\begin{itemize}
\item Create one top-level Module
\item Invoke the Chisel code emitter from the App
\item Pass the top module (e.g., \code{new Hello()})
\item Optional: pass some parameters (in an \code{Array})
\item Following code generates Verilog code for \emph{Hello World}
\end{itemize}
\shortlist{../code/generate.txt}
\end{frame}

%\begin{frame}[fragile]{Generic Components}
%\begin{chisel}
%val c = Mux(cond, a, b)
%\end{chisel}
%\begin{itemize}
%\item This is a multiplexer
%\item Input can be any type
%\end{itemize}
%\end{frame}


\begin{frame}[fragile]{Testing with Chisel}
\begin{itemize}
\item A test contains:
\begin{itemize}
\item a device under test (DUT) and
\item the testing logic
\end{itemize}
\item Set input values with \code{poke}
\item Advance the simulation with \code{step}
\item Read the output values with \code{peek}
\item Compare the values with \code{expect}
\item Import following packages:
\shortlist{../code/test_import.txt}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{An Example DUT}
\begin{itemize}
\item A device-under test (DUT)
\item Just 2-bit AND logic
\shortlist{../code/test_dut.txt}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A ChiselTest}
\begin{itemize}
\item Extends class \code{AnyFlatSpec} with \code{ChiselScalatestTester}
\item Has the device-under test (DUT) as parameter of the \code{test} function
\item Test function contains the test code
\item Testing code can use all features of Scala
\end{itemize}
\end{frame}

%\begin{frame}[fragile]{A Simple Tester}
%\begin{itemize}
%\item Just using \code{println} for manual inspection
%\shortlist{../code/test_bench_simple.txt}
%\end{itemize}
%\end{frame}


\begin{frame}[fragile]{A Test}
\begin{itemize}
\item Poke values and \code{expect} some output
\shortlist{../code/test_bench.txt}
\end{itemize}
\end{frame}

%\begin{frame}[fragile]{Testing}
%\begin{itemize}
%\item Within Chisel with a tester (= Scala program)
%\item May include waveform generation
%\item peek and poke to read and set values
%\begin{itemize}
%\item Remember the BASIC days ;-)
%\end{itemize}
%\item printf in simulation on rising edge
%\begin{chisel}
%printf("Counting %x\n", r1)
%\end{chisel}
%\end{itemize}
%\end{frame}
%
%\begin{frame}[fragile]{Testing Example}
%\shortlist{../code/test_bench_simple.txt}
%\end{frame}


\begin{frame}[fragile]{Summary}
\begin{itemize}
\item Chisel describes digital hardware embedded in Scala
\item Digital design is simple: combinational circuits and registers
\item We will make it more powerful with generator code
\item A digital circuit is organized into components
\item Components have ports with directions
\item Sequential circuits are combinations of registers with combinational circuits
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Lab 3}
\begin{itemize}
\item Components and Small Sequential Circuits
\item \href{https://github.com/schoeberl/chisel-lab/tree/master/lab3}{Chisel Lab 3 Page}
%\item You need to download again, as I have updated the lab
%\begin{itemize}
%\item Or learn to use git and do a  \code{git pull} ;-)
%\end{itemize}
\item Each exercise contains a test, which initially fails
\item \code{sbt test} runs them all
\begin{itemize}
\item To just run a single test, run e.g.,\\
\code{sbt "testOnly SingleTest"}
\end{itemize}
\item When all tests succeed, you're done ;-)
\end{itemize}
\end{frame}


\end{document}

\begin{frame}[fragile]{Title}
\begin{itemize}
\item abc
\end{itemize}
\end{frame}
